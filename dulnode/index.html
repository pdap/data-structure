<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta name="generator" content="nico 0.5.2">
    <meta name="theme" content="one 0.2">
    <meta name="author" content="pdap">
    <meta name="usage" content="all">
    <title>循环双链表的js实现</title>
    <link rel="stylesheet" href="./static/one.css" />
        <style type="text/css">
            #svglogo{
          stroke-dasharray: 200;
          stroke-dashoffset: 200;
          -webkit-animation: dash 5s linear infinite;
          animation: dash 5s linear infinite;
        }
        @-webkit-keyframes dash {
          to {
            stroke-dashoffset: 0;
          }
        }
        @keyframes dash {
          to {
            stroke-dashoffset: 0;
          }
        }
    </style>
  </head>
  <body>
    <div class="header">
      <div class="container">
        <div class="brand">
          <a class="home" href="./"><svg id="svglogo" width="150" height="50" xmlns="http://www.w3.org/2000/svg"><title>Layer 1</title><path d="M18.444 21.778c.223 0 .602-.3 1.112-.667.403-.29 1.012-.782 1.777-1.333.807-.581 1.386-.999 2.445-1.556.709-.373.849-1.177 1.555-1.555a39.51 39.51 0 0 0 1.556-.89c.423-.26.51-.287.667-.444.157-.157.065-.287.222-.444.157-.157.239-.137.444-.222.29-.12.445-.445.667-.667l.222-.222v-.222h.222M28 16v1.778c0 1.333.222 2.889.222 4.222v4.667c0 1.11-.11 2.646-.222 3.555-.109.882-.222 1.556-.222 1.778 0 .444-.108.628-.222 1.111-.052.216 0 .445 0 .667v.666c0 .223.157.732 0 .89-.158.156-.223.444-.223.666v.667c0 .222-.222.444-.222.666 0 .223-.222.223-.222.445v.666c0 .223-.324.377-.445.667-.085.205-.137.461-.222.667-.12.29-.065.51-.222.666-.157.158-.51-.157-.667 0-.157.158-.065.51-.222.667l-.444.445h-.223M29.333 15.333h3.334c.222 0 .461-.085.666 0 .29.12.288.288.445.445.157.157.51.287.666.444.158.157.325.377.445.667.085.205.222.667.222.889 0 .444.137.461.222.666.12.29.223.445.223.667V23.112c0 .221.157.509 0 .666-.158.157-.51-.157-.667 0-.157.157-.222.222-.445.222-.222 0-.222.222-.444.222s-.667.222-.889.222c-.444 0-.51.066-.667.223-.157.157-.287.065-.444.222-.157.157-.444 0-.667 0h-.889c-.222 0-.444.222-.666.222h-.445M49.333 26.444c-.222 0-.708.377-1.11.667-.51.368-1.07.935-1.556 1.333-.62.508-.902.942-1.111 1.334-.379.706-.627.955-1.334 1.333-.196.105-.546.599-.666.889-.085.205-.066.287-.223.444-.157.158 0 .445 0 .667 0 .222-.085.461 0 .667.12.29.377.546.667.666.205.085.244.184.667.445.189.117.444.222.889.444.444.223.67.41.888.445.694.112.821.324 1.112.444.205.085.444 0 .666 0 .222 0 .445 0 .89-.444.221-.222.156-.744.666-1.111.403-.29.38-.714.889-1.334.199-.243.444-.666.666-1.11.223-.445.325-.6.445-.89.17-.41.102-.598.222-.889.085-.205-.085-.46 0-.666.12-.29.222-.445.222-.667v-.667c0-.222-.239-.137-.444-.222-.58-.24-.599-.546-.89-.666-.204-.085-.064-.288-.221-.445-.157-.157-.29-.12 0 0 .205.085.376.486.666.889.184.255.657.566.89 1.333.128.426.221.89.444 1.334.222.444.137.683.222.889.12.29.065.51.222.666.157.157.287.065.445.222.157.158.287.066.444.223.157.157.017.36.222.444.29.12.222.445.445.445.222 0 .256.052.666.222.29.12.445.222.667.222.222 0 .376.324.667.444.205.085.444 0 .666 0H58c.444 0 .672-.07 1.111 0 .694.113 1.333.223 1.556.223h.666M66.444 26.667V30c0 .667.11 1.084.223 1.778.07.438 0 .666 0 .889V34.444c0 .445.157.954 0 1.112-.157.157-.445 0-.89-.223v-.222M66.667 26.667c.222-.223.444-.667.666-.89.223-.221.483-.633.667-.888.29-.403.222-.667.444-.667.223 0 .223-.222.445-.222s.954-.157 1.111 0c.157.157.456.12.889.222.484.114.705.412.889.667.29.403.602.676.666.889.233.767.582 1.128.667 1.333.24.58.547 1.043.667 1.333.085.206.222.667.222.89 0 .222.324.598.444.888.085.206 0 .445 0 .667v.667c0 .222.223.666.223.888v1.334c0 .222.222.222.222.444v.445h.222v.222M87.333 25.333c0-.222-.287-.287-.444-.444-.157-.157.068-.547-.222-.667-.206-.085-.223-.222-.445-.222h-.666c-.223 0-.377-.102-.667-.222-.205-.085-.51-.38-.667-.222-.157.157-.12.456-.222.888-.114.484-.28.844-.444 1.112a2.81 2.81 0 0 0-.445 1.555c0 .222-.137.906-.222 1.111-.12.29-.137.684-.222.89-.12.29.092.574-.223.888-.157.157-.287.065-.444.222-.157.157 0 .89 0 1.111v1.556c0 .222.19.705.444.889.404.29.628.552 1.112.666.216.051.7-.347 1.11.223.13.18.229.17.445.222.484.114.599.324.889.444.205.085.444 0 .667 0 .444 0 .731.157.889 0 .157-.157.222-.222.222-.666 0-.223.108-.628.222-1.111.051-.217.222-.89.222-1.334 0-.222.332-.417.445-1.11.035-.22.222-.445.222-.89 0-.222.222-.222.222-.444s.222-.222.222-.445c0-.444-.085-.683 0-.889.12-.29.138-.46.223-.666.12-.29.222-.445.222-.667v-.667c0-.222.068-.485-.222-.888-.184-.255-.445-.445-.445-.667 0-.222 0-.445-.222-.445s.108.406.222.89c.153.648.116 1.341.222 2 .113.693.338 1.341.445 2 .112.693.222 1.333.222 2v1.333c0 .444.222.889.222 1.11 0 .445.222.89.222 1.112v.889c0 .222-.05.672 0 .889.115.483.223.666.223.889V40.222c0 .222-.33.405-.445.89-.05.215 0 .444 0 .666 0 .444-.065.732-.222.889-.157.157-.287.51-.444.666-.158.157-.24.138-.445.223-.29.12-.461.137-.667.222-.29.12-.376.324-.666.444-.206.085-.575-.092-.89.222-.156.158-.221.223-.444.223-.222 0-.222.222-.444.222s-.461-.085-.667 0c-.29.12-.444.222-.666.222h-1.778c-.222 0-.667.222-.889.222h-.667c-.444 0-.67.036-.889 0-.693-.112-.888-.222-1.11-.222-.445 0-.89 0-1.112-.222-.222-.222-.666-.222-.889-.222h-1.111M99.333 24.667H105.111M113.333 24h4.223c.222 0 .666.222.888.222h.667M103.333 31.111c.445.445.667.889.89 1.111.444.445.352.797.666 1.111l.444.445.445.444c.314.314.708.376 1.11.667.256.184.462.137.668.222.29.12.51.065.666.222.157.157.222.223.445.223h.666c.223 0 .288-.066.445-.223.157-.157.683-.137.889-.222.58-.24.666-.444 1.11-.889.223-.222.514-.297 1.112-.666.267-.166.461-.582.667-.667.29-.12.376-.324.666-.445.206-.085.288-.065.445-.222.157-.157.376-.102.666-.222.206-.085.377-.102.667-.222.41-.17.444-.222.444-.445h.223" stroke-width="2" stroke="#ed0e0e" fill="none"/></svg></a>
        </div>
      </div>
    </div>
    <div class="document yue">
<div class="hentry" itemscope itemtype="http://schema.org/Article">
  <h1 class="entry-title" itemprop="name">循环双链表的js实现</h1>
  <div class="entry-content" itemprop="articleBody"><p>循环双链表的js实现，提供头插尾插，按位查询，按值查询</p>
<hr>
<h2 id="使用方法">使用方法</h2><script> /**
  * [DuLNode 循环双链表的js实现]
  * @param {number||string}   pos   指针
  * @param {object||array||sting||number}   data  数组中的元素
  * @param {DuLNode}   prior 双链前驱结点
  * @param {DuLNode} next  双链后置结点
  */
(function (name, context, factory) {

  // 支持 UMD. AMD, CommonJS/Node.js   
  if (typeof module !== "undefined" && module.exports) {
    module.exports = factory();
  } else if (typeof define === "function" && define.amd) {
    define(factory);
  } else {
    context[name] = factory();
  }

})("DuLNode", this, function () {

    function DuLNode(pos,data, prior, next) {
    this.data = data||null; //数据
    this.pos  = pos;        //指针 
    this.prior = prior || this; // 前驱
    this.next = next|| this;  // 后继
  }
  DuLNode.prototype = {
    // 按位查找
    findByPos:function(pos){
       var p = this.next;       
      // 从当前指针向后查找，直到p为空或者指针为pos，或者指针扫描到自身
      while (p && p!==this&&p.pos!==pos) {
        p = p.next;
      }
       return (!p || p.pos!==pos) ? null : p;
    },
    // 按值查找
    findByValue:function(value){
       var p = this.next;       

      while (p && p!==this&&p.data!==value) {
        p = p.next;
      }
       return (!p || p.data!==value) ? null : p;
    },
    // 头插法
    insertAfter: function (pos,npos, elem) {
      var p;

      if (!(p = this.findByPos(pos))) return false;

      var s = new DuLNode(npos,elem,p,p.next);
      p.next.prior = s;
      p.next = s;

      return true;
    },
        // 尾插法
     insertBefore: function (pos, npos,elem) {
      var p;

      if (!(p = this.findByPos(pos))) return false;

      var s = new DuLNode(npos,elem, p.prior, p);
      p.prior.next = s;
      p.prior = s;
      return true;
    },
    // 头插追加
    addAfter:function(pos,data){
        var p =this;

      var s = new DuLNode(pos,data, p, p.next);
      p.next.prior=s;
      p.next = s;
    },
    // 尾插追加
    addBefore:function(pos,data){
        var p =this;
        //console.log(p);
      var s = new DuLNode(pos,data, p.prior, p);
      p.prior.next=s;
      p.prior = s;
    },
    // 按位删除元素
    listDelete: function (i) {
      var p;
      if (!(p = this.findByPos(i))) return false;
      var e = p.data;
      p.prior.next = p.next;
      p.next.prior = p.prior;

      p = null;

      return e;
    }
  };
  return DuLNode;
});
/**
 * 以数组的第一个元素作为头结点建立循环双链表
 * @param  {[Array]} arr [待处理数组元素]
 * @return {[Object]} DuLNode  [循环双链表]
 */
  function arr2LList(arr){
   var  llist = null;
   for (var i = 0; i < arr.length; i++) {
    if (llist===null) {
       llist = new DuLNode(i,arr[i]) ;
     } else{
       llist.addBefore(i,arr[i]);
     }    
   }
   return llist;
  }
 var test = arr2LList([1,2,3,4,5,6,7,8,9,10]);
 console.log(test,test.next,test.next.next,test.prior,test.prior.prior,test.findByValue(10),test.findByPos(0));</script><div class="highlight"><pre><code class="javascript"> <span class="comment">/**
  * [DuLNode 循环双链表的js实现]
  * @param {number||string}   pos   指针
  * @param {object||array||sting||number}   data  数组中的元素
  * @param {DuLNode}   prior 双链前驱结点
  * @param {DuLNode} next  双链后置结点
  */</span>
(<span class="function"><span class="keyword">function</span> <span class="params">(name, context, factory)</span> {</span>

  <span class="comment">// 支持 UMD. AMD, CommonJS/Node.js   </span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> module !== <span class="string">"undefined"</span> &amp;&amp; module.exports) {
    module.exports = factory();
  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd) {
    define(factory);
  } <span class="keyword">else</span> {
    context[name] = factory();
  }

})(<span class="string">"DuLNode"</span>, <span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>

    <span class="function"><span class="keyword">function</span> <span class="title">DuLNode</span><span class="params">(pos,data, prior, next)</span> {</span>
    <span class="keyword">this</span>.data = data||<span class="literal">null</span>; <span class="comment">//数据</span>
    <span class="keyword">this</span>.pos  = pos;        <span class="comment">//指针 </span>
    <span class="keyword">this</span>.prior = prior || <span class="keyword">this</span>; <span class="comment">// 前驱</span>
    <span class="keyword">this</span>.next = next|| <span class="keyword">this</span>;  <span class="comment">// 后继</span>
  }
  DuLNode.prototype = {
    <span class="comment">// 按位查找</span>
    findByPos:<span class="function"><span class="keyword">function</span><span class="params">(pos)</span>{</span>
       <span class="keyword">var</span> p = <span class="keyword">this</span>.next;       
      <span class="comment">// 从当前指针向后查找，直到p为空或者指针为pos，或者指针扫描到自身</span>
      <span class="keyword">while</span> (p &amp;&amp; p!==<span class="keyword">this</span>&amp;&amp;p.pos!==pos) {
        p = p.next;
      }
       <span class="keyword">return</span> (!p || p.pos!==pos) ? <span class="literal">null</span> : p;
    },
    <span class="comment">// 按值查找</span>
    findByValue:<span class="function"><span class="keyword">function</span><span class="params">(value)</span>{</span>
       <span class="keyword">var</span> p = <span class="keyword">this</span>.next;       

      <span class="keyword">while</span> (p &amp;&amp; p!==<span class="keyword">this</span>&amp;&amp;p.data!==value) {
        p = p.next;
      }
       <span class="keyword">return</span> (!p || p.data!==value) ? <span class="literal">null</span> : p;
    },
    <span class="comment">// 头插法</span>
    insertAfter: <span class="function"><span class="keyword">function</span> <span class="params">(pos,npos, elem)</span> {</span>
      <span class="keyword">var</span> p;

      <span class="keyword">if</span> (!(p = <span class="keyword">this</span>.findByPos(pos))) <span class="keyword">return</span> <span class="literal">false</span>;

      <span class="keyword">var</span> s = <span class="keyword">new</span> DuLNode(npos,elem,p,p.next);
      p.next.prior = s;
      p.next = s;

      <span class="keyword">return</span> <span class="literal">true</span>;
    },
        <span class="comment">// 尾插法</span>
     insertBefore: <span class="function"><span class="keyword">function</span> <span class="params">(pos, npos,elem)</span> {</span>
      <span class="keyword">var</span> p;

      <span class="keyword">if</span> (!(p = <span class="keyword">this</span>.findByPos(pos))) <span class="keyword">return</span> <span class="literal">false</span>;

      <span class="keyword">var</span> s = <span class="keyword">new</span> DuLNode(npos,elem, p.prior, p);
      p.prior.next = s;
      p.prior = s;
      <span class="keyword">return</span> <span class="literal">true</span>;
    },
    <span class="comment">// 头插追加</span>
    addAfter:<span class="function"><span class="keyword">function</span><span class="params">(pos,data)</span>{</span>
        <span class="keyword">var</span> p =<span class="keyword">this</span>;

      <span class="keyword">var</span> s = <span class="keyword">new</span> DuLNode(pos,data, p, p.next);
      p.next.prior=s;
      p.next = s;
    },
    <span class="comment">// 尾插追加</span>
    addBefore:<span class="function"><span class="keyword">function</span><span class="params">(pos,data)</span>{</span>
        <span class="keyword">var</span> p =<span class="keyword">this</span>;
        <span class="comment">//console.log(p);</span>
      <span class="keyword">var</span> s = <span class="keyword">new</span> DuLNode(pos,data, p.prior, p);
      p.prior.next=s;
      p.prior = s;
    },
    <span class="comment">// 按位删除元素</span>
    listDelete: <span class="function"><span class="keyword">function</span> <span class="params">(i)</span> {</span>
      <span class="keyword">var</span> p;
      <span class="keyword">if</span> (!(p = <span class="keyword">this</span>.findByPos(i))) <span class="keyword">return</span> <span class="literal">false</span>;
      <span class="keyword">var</span> e = p.data;
      p.prior.next = p.next;
      p.next.prior = p.prior;

      p = <span class="literal">null</span>;

      <span class="keyword">return</span> e;
    }
  };
  <span class="keyword">return</span> DuLNode;
});
<span class="comment">/**
 * 以数组的第一个元素作为头结点建立循环双链表
 * @param  {[Array]} arr [待处理数组元素]
 * @return {[Object]} DuLNode  [循环双链表]
 */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">arr2LList</span><span class="params">(arr)</span>{</span>
   <span class="keyword">var</span>  llist = <span class="literal">null</span>;
   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {
    <span class="keyword">if</span> (llist===<span class="literal">null</span>) {
       llist = <span class="keyword">new</span> DuLNode(i,arr[i]) ;
     } <span class="keyword">else</span>{
       llist.addBefore(i,arr[i]);
     }    
   }
   <span class="keyword">return</span> llist;
  }
 <span class="keyword">var</span> test = arr2LList([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]);
 console.log(test,test.next,test.next.next,test.prior,test.prior.prior,test.findByValue(<span class="number">10</span>),test.findByPos(<span class="number">0</span>));</code></pre></div><h2 id="参考资料">参考资料</h2><blockquote>
<p><a href="http://www.nowamagic.net/librarys/veda/detail/1876">循环双链表</a>
<img src="./dulnode-1.png" alt="du"></p>
</blockquote>
<hr>
</div>
</div>
</div>
    <div class="footer">
      <p class="copyright">powered by <a href="http://lab.lepture.com/nico/">nico</a> 0.5.2</p>
    </div>
    <script src="./static/one.js"></script>
  </body>
</html>